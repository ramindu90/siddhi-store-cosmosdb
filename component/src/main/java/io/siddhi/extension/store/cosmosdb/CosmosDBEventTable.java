/*
 * Copyright (c) 2019, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
 *
 * WSO2 Inc. licenses this file to you under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */

package io.siddhi.extension.store.cosmosdb;

import com.microsoft.azure.documentdb.ConnectionPolicy;
import com.microsoft.azure.documentdb.ConsistencyLevel;
import com.microsoft.azure.documentdb.Database;
import com.microsoft.azure.documentdb.Document;
import com.microsoft.azure.documentdb.DocumentClient;
import com.microsoft.azure.documentdb.DocumentClientException;
import com.microsoft.azure.documentdb.DocumentCollection;
import com.microsoft.azure.documentdb.FeedOptions;
import com.microsoft.azure.documentdb.RequestOptions;
import com.microsoft.azure.documentdb.SqlQuerySpec;
import io.siddhi.annotation.Example;
import io.siddhi.annotation.Extension;
import io.siddhi.annotation.Parameter;
import io.siddhi.annotation.SystemParameter;
import io.siddhi.annotation.util.DataType;
import io.siddhi.core.exception.ConnectionUnavailableException;
import io.siddhi.core.exception.SiddhiAppCreationException;
import io.siddhi.core.exception.SiddhiAppRuntimeException;
import io.siddhi.core.table.record.AbstractRecordTable;
import io.siddhi.core.table.record.ExpressionBuilder;
import io.siddhi.core.table.record.RecordIterator;
import io.siddhi.core.util.collection.operator.CompiledCondition;
import io.siddhi.core.util.collection.operator.CompiledExpression;
import io.siddhi.core.util.config.ConfigReader;
import io.siddhi.extension.store.cosmosdb.util.CosmosTableConstants;
import io.siddhi.extension.store.cosmosdb.util.CosmosTableUtils;
import io.siddhi.query.api.annotation.Annotation;
import io.siddhi.query.api.definition.Attribute;
import io.siddhi.query.api.definition.TableDefinition;
import io.siddhi.query.api.util.AnnotationHelper;

import java.sql.SQLException;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import static io.siddhi.core.util.SiddhiConstants.ANNOTATION_STORE;

/**
 * Class representing Cosmos DB Event Table implementation.
 */
@Extension(
        name = "cosmosdb",
        namespace = "store",
        description = "This extension will be used to execute Create, Update, Delete, Find and Contains operations on" +
                " document collections in Cosmos DB.",
        parameters = {
                @Parameter(name = "uri",
                        description = "The Cosmos DB uri for the Cosmos DB data store. The uri must be of the " +
                                "format \n https://{databaseaccount}.documents.azure.com/dbs/{db}",
                        type = {DataType.STRING}),
                @Parameter(name = "access.key",
                        description = "The Access key for the Cosmos DB data store generated by the Cosmos DB.",
                        type = {DataType.STRING}),
                @Parameter(name = "database.name",
                        description = "The name of the Cosmos DB database containing this event table. A database " +
                                "in Azure Cosmos DB is a logical container for document collections and users. ",
                        type = {DataType.STRING}),
                @Parameter(name = "collection.name",
                        description = "The name of the collection in the store this Event Table should be " +
                                "persisted as. A collection is a named logical container for JSON documents.",
                        optional = true,
                        defaultValue = "Name of the siddhi event table.",
                        type = {DataType.STRING}),
                @Parameter(name = "custom.request.options",
                        description = "This parameter configures custom options for create, update and delete " +
                                "requests. Expected format '<key>:<value>,<key>:<value>'." +
                                "e.g., 'offerThroughput:500,scriptLoggingEnabled:true'.",
                        type = {DataType.STRING},
                        optional = true,
                        defaultValue = "null"),
                @Parameter(name = "is.disable.ru.per.minute.usage",
                        description = "is.disable.ru.per.minute.usage is used to enable/disable Request " +
                                "Units(RUs)/minute capacity to serve the request if regular provisioned RUs/second " +
                                "is exhausted. Possible values are 'true' or 'false'.",
                        type = {DataType.STRING},
                        optional = true,
                        defaultValue = "false"),
                @Parameter(name = "offer.enable.ru.per.minute.throughput",
                        description = "Sets offerEnableRUPerMinuteThroughput for a collection in the Azure Cosmos " +
                                "DB database service. Possible values are 'true' or 'false'.",
                        type = {DataType.STRING},
                        optional = true,
                        defaultValue = "false"),
                @Parameter(name = "partition.key",
                        description = "Sets the partition key used to identify the current request's target partition.",
                        type = {DataType.STRING},
                        optional = true,
                        defaultValue = "null"),
                @Parameter(name = "offer.throughput",
                        description = "Sets the throughput in the form of Request Units per second when creating " +
                                "a document collection. Possible values for this parameter are positive integers.",
                        type = {DataType.STRING},
                        optional = true,
                        defaultValue = "null"),
                @Parameter(name = "offer.type",
                        description = "Sets the offer type when creating a document collection.",
                        type = {DataType.STRING},
                        optional = true,
                        defaultValue = "null"),
                @Parameter(name = "resource.token.expiry.seconds",
                        description = "Sets the expiry time for resource token. Used when creating, updating, " +
                                "reading permission. Possible values for this parameter are positive integers.",
                        type = {DataType.STRING},
                        optional = true,
                        defaultValue = "null"),
                @Parameter(name = "session.token",
                        description = "Sets the token for use with session consistency.",
                        type = {DataType.STRING},
                        optional = true,
                        defaultValue = "null"),
                @Parameter(name = "indexing.directive",
                        description = "Specifies whether or not the resource is to be indexed in the Azure Cosmos" +
                                " DB database service. Possible values are 'Default', 'Include' or 'Exclude'.",
                        type = {DataType.STRING},
                        optional = true,
                        defaultValue = "null"),
                @Parameter(name = "access.condition.type",
                        description = "Specifies the set of access condition types that can be used for operations " +
                                "in the Azure Cosmos DB database service. Possible values are 'IfMatch' or " +
                                "'IfNoneMatch'.",
                        type = {DataType.STRING},
                        optional = true,
                        defaultValue = "null"),
                @Parameter(name = "access.condition",
                        description = "Sets the value of the condition - for AccessConditionType IfMatchs and " +
                                "IfNotMatch, this is the ETag that has to be compared to.",
                        type = {DataType.STRING},
                        optional = true,
                        defaultValue = "null"),
                @Parameter(name = "pre.trigger.include",
                        description = "Sets the triggers to be invoked before the operation.",
                        type = {DataType.STRING},
                        optional = true,
                        defaultValue = "null"),
                @Parameter(name = "post.trigger.include",
                        description = "Sets the triggers to be invoked after the operation.",
                        type = {DataType.STRING},
                        optional = true,
                        defaultValue = "null"),
                @Parameter(name = "disable.automatic.id.generation",
                        description = "Sets whether Ids are auto generated by the Cosmos DB for documents. Possible " +
                                "values are 'true' or 'false'.",
                        type = {DataType.STRING},
                        optional = true,
                        defaultValue = "false"),
                @Parameter(name = "partition.key.range.id",
                        description = "Sets the partitionKeyRangeId on query options.",
                        type = {DataType.STRING},
                        optional = true,
                        defaultValue = "null"),
                @Parameter(name = "is.enable.scan.in.query",
                        description = "Sets the option to allow scan on the queries which couldn't be served as " +
                                "indexing was opted out on the requested paths. Possible values are 'true' or 'false'.",
                        type = {DataType.STRING},
                        optional = true,
                        defaultValue = "false"),
                @Parameter(name = "is.emit.verbose.traces.in.query",
                        description = "Sets the option to allow queries to emit out verbose traces for investigation.",
                        type = {DataType.STRING},
                        optional = true,
                        defaultValue = "false"),
                @Parameter(name = "is.enable.cross.partition.query",
                        description = "Sets the option to allow queries to run across all partitions of the " +
                                "collection.",
                        type = {DataType.STRING},
                        optional = true,
                        defaultValue = "false"),
                @Parameter(name = "max.degree.of.parallelism",
                        description = "Sets the number of concurrent operations run client side during parallel query" +
                                " execution.",
                        type = {DataType.STRING},
                        optional = true,
                        defaultValue = "0"),
                @Parameter(name = "max.buffered.item.count",
                        description = "Sets the maximum number of items that can be buffered client side during " +
                                "parallel query execution.",
                        type = {DataType.STRING},
                        optional = true,
                        defaultValue = "0"),
                @Parameter(name = "response.continuation.token.limit.in.kb",
                        description = "Sets the ResponseContinuationTokenLimitInKb feed option for document query " +
                                "requests in the Azure Cosmos DB service. ResponseContinuationTokenLimitInKb is used " +
                                "to limit the length of continuation token in the query response. Valid values are " +
                                "&gt;= 1.",
                        type = {DataType.STRING},
                        optional = true,
                        defaultValue = "0")
        },
        systemParameter = {
                @SystemParameter(name = "requestTimeout",
                        description = "Sets the request timeout (time to wait for response from network peer) in " +
                                "seconds.",
                        defaultValue = "60",
                        possibleParameters = "any positive integer"),
                @SystemParameter(name = "directRequestTimeout",
                        description = "Sets the direct mode request timeout (time to wait for response from network " +
                                "peer) in seconds. This only applies to requests that talk directly to the backend. ",
                        defaultValue = "5",
                        possibleParameters = "any positive integer"),
                @SystemParameter(name = "mediaRequestTimeout",
                        description = "Sets time to wait for response from network peer for attachment content " +
                                "(aka media) operations in seconds.",
                        defaultValue = "300",
                        possibleParameters = "any positive integer"),
                @SystemParameter(name = "connectionMode",
                        description = "Sets the connection mode used in the client. Direct and Gateway connectivity " +
                                "modes are supported",
                        defaultValue = "Gateway",
                        possibleParameters = {"Gateway", "DirectHttps"}),
                @SystemParameter(name = "mediaReadMode",
                        description = "Sets the attachment content (aka media) download mode.",
                        defaultValue = "Buffered",
                        possibleParameters = {"Buffered", "Streamed"}),
                @SystemParameter(name = "maxPoolSize",
                        description = "Sets the value of the connection pool size of the httpclient.",
                        defaultValue = "100",
                        possibleParameters = "any positive integer"),
                @SystemParameter(name = "idleConnectionTimeout",
                        description = "Sets the value of the timeout for an idle connection in seconds. After that " +
                                "time, the connection will be automatically closed.",
                        defaultValue = "60",
                        possibleParameters = "any positive integer"),
                @SystemParameter(name = "userAgentSuffix",
                        description = "Sets the value to be appended to the user-agent header, this is used for " +
                                "monitoring purposes",
                        defaultValue = "\"\"",
                        possibleParameters = "any String value"),
                @SystemParameter(name = "MaxRetryAttemptsOnThrottledRequests",
                        description = "Sets the maximum number of retries in the case where the request fails " +
                                "because the service has applied rate limiting on the client. The default value is " +
                                "9. This means in the case where the request is throttled, the same request will be " +
                                "issued for a maximum of 10 times to the server before an error is returned to " +
                                "the application.",
                        defaultValue = "9",
                        possibleParameters = "any positive integer"),
                @SystemParameter(name = "MaxRetryWaitTimeInSeconds",
                        description = "Sets the maximum retry time in seconds. When a request fails due to a " +
                                "throttle error, the service sends back a response that contains a value indicating " +
                                "the client should not retry before the time period has elapsed (Retry-After). " +
                                "The MaxRetryWaitTime flag allows the application to set a maximum wait time for " +
                                "all retry attempts.",
                        defaultValue = "30",
                        possibleParameters = "any positive integer"),
                @SystemParameter(name = "enableEndpointDiscovery",
                        description = "Sets the flag to enable endpoint discovery for geo-replicated database " +
                                "accounts. When EnableEndpointDiscovery is true, the extension will automatically " +
                                "discover the current write and read regions to ensure requests are sent to the " +
                                "correct region based on the capability of the region and the user's preference.",
                        defaultValue = "true",
                        possibleParameters = {"true", "false"}),
                @SystemParameter(name = "preferredLocations",
                        description = "Sets the preferred locations for geo-replicated database accounts. For " +
                                "example, \"East US\" as the preferred location. If EnableEndpointDiscovery is set " +
                                "to false, this property is ignored.",
                        defaultValue = "null",
                        possibleParameters = "list of valid locations"),
                @SystemParameter(name = "usingMultipleWriteLocations",
                        description = "Sets the value to enable writes on any locations (regions) for geo-replicated " +
                                "database accounts. When the value of this property is true, the SDK will direct " +
                                "write operations to available writable locations of geo-replicated database " +
                                "account. Writable locations are ordered by PreferredLocations property. Setting the " +
                                "property value to true has no effect until EnableMultipleWriteLocations in " +
                                "DatabaseAccount is also set to true.",
                        defaultValue = "false",
                        possibleParameters = {"true", "false"}),
                @SystemParameter(name = "handleServiceUnavailableFromProxy",
                        description = "Sets the value to handle service unavailable errors returned without a " +
                                "service version header, by a proxy. When the value of this property is true, the " +
                                "extension will handle it as a known error and perform retries.",
                        defaultValue = "false",
                        possibleParameters = {"true", "false"}),
                @SystemParameter(name = "consistencyLevel",
                        description = "Represents the consistency levels supported for Azure Cosmos DB client " +
                                "operations in the Azure Cosmos DB database service. The requested ConsistencyLevel " +
                                "must match or be weaker than that provisioned for the database account. Consistency " +
                                "levels by order of strength are Strong, BoundedStaleness, Session and Eventual.",
                        defaultValue = "Session",
                        possibleParameters = {"Strong", "BoundedStaleness", "Session", "Eventual", "ConsistentPrefix"})
        },
        examples = {
                @Example(
                        syntax = "@Store(type=\"cosmosdb\"," +
                                "uri=\"https://myCosmosDBName.documents.azure.com:443\", \n" +
                                "access.key= 'access key generated by the Cosmos DB', \n " +
                                "database.name=\"admin\") \n" +
                                "define table FooTable (symbol string, price float, volume long);",
                        description = "The above example creates an event table named 'FooTable' in the database if" +
                                " it does not already exist (with three attributes named 'symbol', 'price', and " +
                                "'volume' of the types 'string', 'float', and 'long' respectively). " +
                                "The connection is made as specified by the parameters configured for the " +
                                "'@Store' annotation."
                ),
                @Example(
                        syntax = "@Store(type=\"cosmosdb\"," +
                                "uri=\"https://myCosmosDBName.documents.azure.com:443\", \n" +
                                "access.key= 'access key generated by the Cosmos DB', \n " +
                                "database.name=\"admin\") \n" +
                                "define table FooTable (symbol string, price float, volume long);\n" +
                                "define stream InputStream (symbol string, volume long);\n" +
                                "from InputStream as a join FooTable as b on str:contains(b.symbol, a.symbol)\n" +
                                "select a.symbol as symbol, b.volume as volume\n" +
                                "insert into FooStream;",
                        description = "The above example creates an event table named 'FooTable' in the database if" +
                                " it does not already exist (with three attributes named 'symbol', 'price', and " +
                                "'volume' of the types 'string', 'float' and 'long' respectively). Then the table is " +
                                "joined with a stream named 'InputStream' based on a condition. The following " +
                                "operations are included in the condition:\n" +
                                "[ AND, OR, Comparisons( <  <=  >  >=  == !=), IS NULL, " +
                                "NOT, str:contains(Table<Column>, Stream<Attribute> or Search.String)]"
                ),
                @Example(
                        syntax = "@Store(type=\"cosmosdb\"," +
                                "uri=\"https://myCosmosDBName.documents.azure.com:443\", \n" +
                                "access.key= 'access key generated by the Cosmos DB', \n " +
                                "database.name=\"admin\") \n" +
                                "define table FooTable (symbol string, price float, volume long);\n" +
                                "define stream deleteStream (symbol string);\n" +
                                "from deleteStream \n" +
                                "delete FooTable \n" +
                                "on FooTable.symbol == symbol ;",
                        description = "The above example creates an event table named 'FooTable' in the database if" +
                                " it does not already exist (with three attributes named 'symbol', 'price', and " +
                                "'volume' of the types 'string', 'float' and 'long' respectively). Then documents in " +
                                "the FooTable which match the 'symbol' given in 'deleteStream', are deleted."
                ),
                @Example(
                        syntax = "@Store(type=\"cosmosdb\"," +
                                "uri=\"https://myCosmosDBName.documents.azure.com:443\", \n" +
                                "access.key= 'access key generated by the Cosmos DB', \n " +
                                "database.name=\"admin\") \n" +
                                "define table FooTable (symbol string, price float, volume long);\n" +
                                "define stream updateStream (symbol string, price float);\n" +
                                "from updateStream \n" +
                                "update FooTable \n" +
                                "on FooTable.symbol == symbol ;",
                        description = "The above example creates an event table named 'FooTable' in the database if" +
                                " it does not already exist (with three attributes named 'symbol', 'price', and " +
                                "'volume' of the types 'string', 'float' and 'long' respectively). Then documents in " +
                                "the FooTable which match the 'symbol' given in 'updateStream', are updated with " +
                                "values given in the 'updateStream'."
                ),
                @Example(
                        syntax = "@Store(type=\"cosmosdb\"," +
                                "uri=\"https://myCosmosDBName.documents.azure.com:443\", \n" +
                                "access.key= 'access key generated by the Cosmos DB', \n " +
                                "database.name=\"admin\") \n" +
                                "define table FooTable (symbol string, price float, volume long);\n" +
                                "define stream updateOrInsertStream (symbol string, price float);\n" +
                                "from updateOrInsertStream \n" +
                                "update or insert into FooTable \n" +
                                "on FooTable.symbol == symbol ;",
                        description = "The above example creates an event table named 'FooTable' in the database if" +
                                " it does not already exist (with three attributes named 'symbol', 'price', and " +
                                "'volume' of the types 'string', 'float' and 'long' respectively). Then documents in " +
                                "the FooTable which match the 'symbol' given in 'updateOrInsertStream', are updated " +
                                "with values given in the 'updateOrInsertStream'. If there are no matching documents," +
                                " new documents are created with the given values."
                ),
                @Example(
                        syntax = "@Store(type=\"cosmosdb\"," +
                                "uri=\"https://myCosmosDBName.documents.azure.com:443\", \n" +
                                "access.key= 'access key generated by the Cosmos DB', \n " +
                                "database.name=\"admin\") \n" +
                                "define table FooTable (symbol string, price float, volume long);\n" +
                                "@sink(type='log')\n" +
                                "define stream logStream(symbol string, price float); \n" +
                                "define stream searchStream (symbol string, price float);\n" +
                                "from searchStream as s join FooTable as t \n" +
                                "on s.price == t.price \n" +
                                "select t.symbol, t.price \n " +
                                "having t.volume > 100" +
                                "order by t.symbol asc" +
                                "insert into logStream;",
                        description = "The above example creates an event table named 'FooTable' in the database if" +
                                " it does not already exist (with three attributes named 'symbol', 'price', and " +
                                "'volume' of the types 'string', 'float' and 'long' respectively). Then documents in " +
                                "the FooTable which match the 'price' given in 'searchStream' and having 'volume' " +
                                "greater than 100 are selected. From these documents, 'symbol' and 'price' attributes" +
                                " are selected, sorted in ascending order according to the 'symbol' attribute values" +
                                " and inserted into the logStream."
                ),
                @Example(
                        syntax = "@Store(type=\"cosmosdb\"," +
                                "uri=\"https://myCosmosDBName.documents.azure.com:443\", \n" +
                                "access.key= 'access key generated by the Cosmos DB', \n " +
                                "database.name=\"admin\") \n" +
                                "define table FooTable (symbol string, price float, volume long);\n" +
                                "@sink(type='log')\n" +
                                "define stream logStream(symbol string, price float); \n" +
                                "define stream containsStream (symbol string, price float);\n" +
                                "from containsStream \n" +
                                "[(FooTable.symbol == symbol and FooTable.price == price) in FooTable] \n" +
                                "insert into logStream;",
                        description = "The above example creates an event table named 'FooTable' in the database if" +
                                " it does not already exist (with three attributes named 'symbol', 'price', and " +
                                "'volume' of the types 'string', 'float' and 'long' respectively). Then if there are" +
                                " documents in the FooTable which match the 'symbol' and 'price' given in " +
                                "'containsStream', those attribute values are inserted into the logStream."
                )
        }
)
public class CosmosDBEventTable extends AbstractRecordTable {
    private DocumentClient documentClient;
    private List<String> attributeNames;
    private String databaseId;
    private String collectionId;
    private String collectionLink;
    private DocumentCollection documentCollection;
    private RequestOptions requestOptions;
    private FeedOptions feedOptions;
    private boolean disableAutomaticIdGeneration;

    @Override
    protected void init(TableDefinition tableDefinition, ConfigReader configReader) {
        this.attributeNames =
                tableDefinition.getAttributeList().stream().map(Attribute::getName).collect(Collectors.toList());
        Annotation storeAnnotation = AnnotationHelper.getAnnotation(ANNOTATION_STORE, tableDefinition.getAnnotations());
        this.databaseId = storeAnnotation.getElement(CosmosTableConstants.ANNOTATION_ELEMENT_DATABASE_NAME);
        if (CosmosTableUtils.isEmpty(databaseId)) {
            throw new SiddhiAppCreationException("Required parameter '" +
                    CosmosTableConstants.ANNOTATION_ELEMENT_DATABASE_NAME + "' cannot be empty for store '" +
                    collectionId + "'. ");
        }
        String customCollectionName =
                storeAnnotation.getElement(CosmosTableConstants.ANNOTATION_ELEMENT_COLLECTION_NAME);
        this.collectionId = CosmosTableUtils.isEmpty(customCollectionName) ? tableDefinition.getId() :
                customCollectionName;
        this.createDocumentClient(storeAnnotation, configReader);
        disableAutomaticIdGeneration = Boolean.parseBoolean(storeAnnotation.getElement(
                CosmosTableConstants.ANNOTATION_ELEMENT_ID_GENERATION));
        requestOptions = CosmosTableUtils.getCustomRequestOptions(storeAnnotation);
        feedOptions = CosmosTableUtils.getFeedOptions(storeAnnotation);
    }

    /**
     * Method for creating Document Client.
     *
     * @param storeAnnotation the source annotation which contains the needed parameters.
     * @param configReader Returns the value of a system property if set else the default value is returned
     *
     */
    private void createDocumentClient(Annotation storeAnnotation, ConfigReader configReader) {
        String uri = storeAnnotation.getElement(CosmosTableConstants.ANNOTATION_ELEMENT_URI);
        String accessKey = storeAnnotation.getElement(CosmosTableConstants.ANNOTATION_ELEMENT_ACCESS_KEY);
        ConnectionPolicy connectionPolicy = CosmosTableUtils.generateConnectionPolicy(configReader);
        ConsistencyLevel consistencyLevel = ConsistencyLevel.valueOf(configReader.readConfig(
                CosmosTableConstants.CONSISTENCY_LEVEL, String.valueOf(ConsistencyLevel.Session)));
        if (CosmosTableUtils.isEmpty(uri)) {
            throw new SiddhiAppCreationException("Required parameter '" + CosmosTableConstants.ANNOTATION_ELEMENT_URI
                    + "' cannot be empty for store '" + collectionId + "'. ");
        } else if (CosmosTableUtils.isEmpty(accessKey)) {
            throw new SiddhiAppCreationException("Required parameter '" +
                    CosmosTableConstants.ANNOTATION_ELEMENT_ACCESS_KEY + "' cannot be empty for store '" +
                    collectionId + "'. ");
        } else {
            documentClient = new DocumentClient(uri, accessKey, connectionPolicy, consistencyLevel);
        }
    }

    @Override
    protected void connect() throws ConnectionUnavailableException {
        String databaseQuery = CosmosTableConstants.SQL_SELECT_FROM_ROOT.replaceFirst(
                CosmosTableConstants.SQL_QUESTION_MARK, "'" + databaseId + "'");
        List<Database> databaseList =
                documentClient.queryDatabases(databaseQuery, feedOptions).getQueryIterable().toList();
        if (databaseList.size() == 1) {
            Database database = databaseList.get(0);
            String collectionQuery = CosmosTableConstants.SQL_SELECT_FROM_ROOT.replaceFirst(
                    CosmosTableConstants.SQL_QUESTION_MARK, "'" + collectionId + "'");
            List<DocumentCollection> collectionList = documentClient.queryCollections(database.getSelfLink(),
                    collectionQuery, feedOptions).getQueryIterable().toList();
            if (collectionList.size() == 1) {
                documentCollection = collectionList.get(0);
            } else {
                try {
                    DocumentCollection collectionDefinition = new DocumentCollection();
                    collectionDefinition.setId(collectionId);
                    try {
                    documentCollection = documentClient.createCollection(database.getSelfLink(),
                            collectionDefinition, requestOptions).getResource();
                    } catch (ClassCastException e) {
                        //Ignored the exception since a Document Collection is returned by createCollection method.
                    }
                } catch (DocumentClientException e) {
                    throw new SiddhiAppCreationException("Failed to create the collection '" + collectionId + "'. ", e);
                }
            }
            if (documentCollection != null) {
                collectionLink = documentCollection.getSelfLink();
            } else {
                throw new SiddhiAppCreationException("Failed to find or create the Document collection "
                        + collectionId);
            }
        } else {
            throw new ConnectionUnavailableException("Database " + databaseId + " doesn't exist. ");
        }
    }

    @Override
    protected void add(List<Object[]> records) {
        for (Object[] record : records) {
            Document insertDocument = new Document();
            for (int counter = 0; counter < this.attributeNames.size(); counter++) {
                String key = this.attributeNames.get(counter);
                Object value = record[counter];
                insertDocument.set(key, value);
            }
            try {
                documentClient.createDocument(collectionLink, insertDocument, requestOptions,
                        disableAutomaticIdGeneration);
            } catch (DocumentClientException e) {
                throw new SiddhiAppRuntimeException("Failed to add document to store: '" + collectionId + "'", e);
            }
        }
    }

    @Override
    protected RecordIterator<Object[]> find(Map<String, Object> findConditionParameterMap,
                                            CompiledCondition compiledCondition) {
        List<Document> documentList;
        try {
            documentList = queryDocuments((CosmosCompiledCondition) compiledCondition, findConditionParameterMap);
        } catch (SQLException e) {
            throw new SiddhiAppRuntimeException("Error retrieving documents from store '" + collectionId + "'. ",
                    e);
        }
        return new CosmosIterator(documentList, this.attributeNames);
    }

    @Override
    protected boolean contains(Map<String, Object> containsConditionParameterMap,
                               CompiledCondition compiledCondition) {
        List<Document> documentList;
        try {
            documentList = queryDocuments((CosmosCompiledCondition) compiledCondition, containsConditionParameterMap);
        } catch (SQLException e) {
            throw new SiddhiAppRuntimeException("Error performing contains check for store '" + collectionId +
                    "'. ", e);
        }
        if (documentList != null) {
            return documentList.size() > 0;
        } else {
            return false;
        }
    }

    @Override
    protected void delete(List<Map<String, Object>> deleteConditionParameterMaps,
                          CompiledCondition compiledCondition) {
        try {
            for (Map<String, Object> deleteConditionParameterMap : deleteConditionParameterMaps) {
                List<Document> documentList = queryDocuments((CosmosCompiledCondition) compiledCondition,
                        deleteConditionParameterMap);
                for (Document toDeleteDocument : documentList) {
                    try {
                        documentClient.deleteDocument(toDeleteDocument.getSelfLink(), requestOptions);
                    } catch (DocumentClientException e) {
                        throw new SiddhiAppRuntimeException("Error performing document deletion for store: '" +
                                collectionId + "'. ", e);
                    }
                }
            }
        } catch (SQLException e) {
            throw new SiddhiAppRuntimeException("Error performing document deletion for store: '" +
                    collectionId + "'. ", e);
        }
    }

    @Override
    protected void update(CompiledCondition compiledCondition, List<Map<String, Object>> updateConditionParameterMaps,
                          Map<String, CompiledExpression> map, List<Map<String, Object>> updateSetParameterMaps) {
        for (int i = 0; i < updateConditionParameterMaps.size(); i++) {
            Map<String, Object> updateConditionParameterMap = null;
            for (Map<String, Object> conditionParameters : updateConditionParameterMaps) {
                updateConditionParameterMap = conditionParameters;
            }
            int ordinal = updateConditionParameterMaps.indexOf(updateConditionParameterMap);
            List<Document> documentList;
            try {
                documentList = queryDocuments((CosmosCompiledCondition) compiledCondition, updateConditionParameterMap);
            } catch (SQLException e) {
                throw new SiddhiAppRuntimeException("Error performing document update operations for store '" +
                        collectionId + "'. ", e);
            }
            if (documentList != null) {
                for (Document toUpdateDocument : documentList) {
                    try {
                        for (String key : updateSetParameterMaps.get(ordinal).keySet()) {
                            Object value = updateSetParameterMaps.get(ordinal).get(key);
                            toUpdateDocument.set(key, value);
                        }
                        documentClient.replaceDocument(toUpdateDocument, requestOptions);
                    } catch (DocumentClientException e) {
                        throw new SiddhiAppRuntimeException("Error performing document update operations for store '" +
                                collectionId + "'. ", e);
                    }
                }
            }
        }
    }

    @Override
    protected void updateOrAdd(CompiledCondition compiledCondition,
                               List<Map<String, Object>> updateConditionParameterMaps,
                               Map<String, CompiledExpression> map, List<Map<String, Object>> updateSetParameterMaps,
                               List<Object[]> addingDocuments) {
        for (int i = 0; i < updateConditionParameterMaps.size(); i++) {
            Map<String, Object> updateOrAddConditionParameterMap = null;
            for (Map<String, Object> conditionParameters : updateConditionParameterMaps) {
                updateOrAddConditionParameterMap = conditionParameters;
            }
            int ordinal = updateConditionParameterMaps.indexOf(updateOrAddConditionParameterMap);
            List<Document> documentList;
            try {
                documentList = queryDocuments((CosmosCompiledCondition) compiledCondition,
                        updateOrAddConditionParameterMap);
            } catch (SQLException e) {
                throw new SiddhiAppRuntimeException("Error performing update/insert operations for store '" +
                        collectionId + "'. ", e);
            }
            if (documentList != null) {
                if (documentList.size() > 0) {
                    for (Document toUpdateDocument : documentList) {
                        try {
                            for (String key : updateSetParameterMaps.get(ordinal).keySet()) {
                                Object value = updateSetParameterMaps.get(ordinal).get(key);
                                toUpdateDocument.set(key, value);
                            }
                            documentClient.replaceDocument(toUpdateDocument, requestOptions);
                        } catch (DocumentClientException e) {
                            throw new SiddhiAppRuntimeException("Error performing update/insert operations for " +
                                    "store '" + collectionId + "'. ", e);
                        }
                    }
                } else {
                    add(addingDocuments);
                }
            }
        }
    }

    @Override
    protected CompiledCondition compileCondition(ExpressionBuilder expressionBuilder) {
        CosmosConditionVisitor visitor = new CosmosConditionVisitor(this.collectionId, false);
        expressionBuilder.build(visitor);
        return new CosmosCompiledCondition(visitor.returnCondition(), visitor.getParameters(),
                expressionBuilder.getUpdateOrInsertReducer(), expressionBuilder.getInMemorySetExpressionExecutor());
    }

    @Override
    protected CompiledExpression compileSetAttribute(ExpressionBuilder expressionBuilder) {
        return compileCondition(expressionBuilder);
    }

    private List<Document> queryDocuments(CosmosCompiledCondition compiledCondition,
                                          Map<String, Object> conditionParameterMap) throws SQLException {
        String condition = CosmosTableUtils.resolveCondition(compiledCondition, conditionParameterMap);
        SqlQuerySpec query = new SqlQuerySpec();
        String queryText = CosmosTableConstants.SQL_SELECT.replaceFirst(
                CosmosTableConstants.SQL_QUESTION_MARK, collectionId);
        queryText = queryText.replaceFirst(CosmosTableConstants.SQL_QUESTION_MARK, condition);
        query.setQueryText(queryText);
        return documentClient.queryDocuments(collectionLink, query, feedOptions).getQueryIterable().toList();
    }

    @Override
    protected void disconnect() {
        documentCollection = null;
        if (documentClient != null) {
            documentClient.close();
        }
    }

    @Override
    protected void destroy() {
        this.disconnect();
    }
}
